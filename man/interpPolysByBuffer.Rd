% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/interpPolysByBuffer.r
\name{interpPolysByBuffer}
\alias{interpPolysByBuffer}
\title{Spatial interpolation between polygon borders}
\usage{
interpPolysByBuffer(
  x1,
  x2,
  eaCrs,
  between,
  method = "grow",
  delta = 1000,
  quadsegs = 5,
  verbose = TRUE
)
}
\arguments{
\item{x1}{SpatialPolygon or SpatialPolygonDataFrame object in an unprojected (WGS84) coordinate reference system.}

\item{x2}{SpatialPolygon or SpatialPolygonDataFrame object in an unprojected (WGS84) coordinate reference system.}

\item{eaCrs}{Character string or object of class CRS. Coordinate reference system (proj4string) for an equal-area projection.}

\item{between}{Numeric between 0 an 1. For areas where \code{x2} is inside \code{x1}, then this is the relative distance from \code{x1} to \code{x2} to place the interpolated border (to a precision determined by \code{delta}). For areas where \code{x2} is outside \code{x1} but part of \code{x2} overlaps \code{x1}, this is relative distance from \code{x1} to the part of \code{x2} outside \code{x1} to place the interpolated polygon border. A value of 0.5 will place the interpolated border between \code{x1} and \code{x2}.}

\item{method}{Either \code{'grow'} or \code{'shrink'}. A growing interpolation uses a series of increasing buffers around the outside of \code{x2}. A shrinking buffer uses a series of smaller buffers inside \code{x1}.}

\item{delta}{Positive numeric, represents distance (typically in meters) by which to grow the buffer at each step. Smaller values yield more accurate interpolation but increase processing time.}

\item{quadsegs}{Positive integer, number of line segments to use to approximate a quarter circle. Larger numbers will yield more accurate results but also require more time.}

\item{verbose}{Logical or integer, if 0 or \code{FALSE} then display no progress indicators. If \code{TRUE} or 1 (default) then display some, if 2 or more display even more.}
}
\value{
A SpatialPolygons object.
}
\description{
This function interpolates between the borders of overlapping spatial polygons.
}
\examples{
\dontrun{
xx1 <- c(44.02, 43.5, 42.61, 42.18, 42, 42.41, 42.75, 41.75, 41.49, 43.61,
46.02, 46.5, 47.5, 47.39, 48.64, 49.05, 48.46, 48.18, 47.54, 46.73)
yy1 <- c(-18.83, -18.67, -18.87, -19.67, -20.65, -21.64, -23.08, -24.9,
-26.51, -27.09, -26.74, -25.6, -25.14, -26.44, -26.46, -24.96, -23.63, -22.72,
-23.36, -22.29)
xy1 <- cbind(xx1, yy1)

xx2 <- c(44.53, 44.18, 44.00, 42.93, 42.29, 42.71, 43.43, 45.15, 46.08, 45.94,
45.36, 45.76, 46.97, 46.87, 45.94, 45.97, 45.08, 44.50, 44.58)
yy2 <- c(-24.27, -23.68, -22.86, -21.88, -20.56, -19.31, -20.36, -20.53, -20.93,
-21.81, -21.64, -22.90, -23.44, -24.08, -24.76, -25.95, -25.88, -25.61, -24.46)
xy2 <- cbind(xx2, yy2)

x1 <- coordsToPoly(xy1, enmSdm::getCRS('wgs84'))
x2 <- coordsToPoly(xy2, enmSdm::getCRS('wgs84'))

plot(x1)
plot(x2, border='blue', add=TRUE)

eaCrs <- enmSdm::getCRS('madAlbers')

inter <- interpPolysByDist(
	x1, x2, eaCrs=eaCrs, between = 0.3, delta=10000
)

plot(inter, lty='dotted', add=TRUE)
}
}
\seealso{
\code{\link[birdsEye]{interPolysByDist}}
}
