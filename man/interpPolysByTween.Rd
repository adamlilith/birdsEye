% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/interpPolysByTween.r
\name{interpPolysByTween}
\alias{interpPolysByTween}
\title{Spatial interpolation between polygon borders using tweening}
\usage{
interpPolysByTween(
  x1,
  x2,
  between,
  delta = 20,
  eaCrs = "oae",
  method = "cubic-in-out",
  verbose = TRUE
)
}
\arguments{
\item{x1}{SpatialPolygon or SpatialPolygonDataFrame object in an unprojected (WGS84) coordinate reference system.}

\item{x2}{SpatialPolygon or SpatialPolygonDataFrame object in an unprojected (WGS84) coordinate reference system.}

\item{between}{Numeric between 0 and 1. This is the relative distance from \code{x1} to \code{x2} to place the interpolated border (higher values of \code{delta} increase precision but also increase computational time). A value of 0 should return a polygon the same as \code{x1} and a value of 1 should return a polygon the same as \code{x2}.}

\item{delta}{Positive numeric, represents distance (typically in meters) by which to grow the buffer at each step. Smaller values yield more accurate interpolation but increase processing time.}

\item{eaCrs}{This is either a proj4 string, an object of class \code{CRS}, or an abbreviated name of equal-area projection to use. The polygons will be projected to this coordinate reference system before interpolation. Ideally, the center point of the projection should be in the center of the polygons to minimize distortion. See \code{\link[birdsEye]{makeCRS}}. Options include:
\itemize{
\item \code{'laea'}: Lambert azimuthal equal-area
 \item \code{'mollweide'}: Mollweide (equal-area)
 \item \code{'oae'} (default) or \code{aeqd}: oblique azimuthal equidistant projection
}}

\item{method}{"Ease" method used to optimize tweened polygons. Any of: \code{'linear'}, \code{'quadratic'}, \code{'cubic'}, \code{'quartic'}, \code{'quintic'}, \code{'sine'}, \code{'circular'}, \code{'exponential'}, \code{'elastic'}, \code{'back'}, \code{'bounce'}. For example, \code{'cubic-in-out'} or \code{'linear-in-out'}. See \code{\link[tweenr]{display_ease}}.}

\item{verbose}{Logical. If \code{TRUE} then display progress indicators.}
}
\value{
SpatialPolygons object.
}
\description{
This function recreates stages in the morphing of one SpatialPolygon* to another. The output is a SpatialPolygons object with borders that are "between" the borders of two other SpatialPolygons* objects. This particular function uses spatial tweening to estimate vertices of polygons.
}
\details{
Although higher values of \code{delta} may seem to generate smoother translations, in some cases smaller values can address weirdnesses (e.g., holes that appear and disappear then appear again).
}
\examples{
\donttest{
# create "x1": has two sub-polygons
x <- c(44.02, 43.5, 42.61, 42.18, 42, 42.41, 42.75, 41.75, 41.49,
43.61,46.02, 46.5, 47.5, 47.39, 48.64, 49.05, 48.46, 48.18, 47.54, 46.73, 45.80, 45.59)
y <- c(-18.83, -18.67, -18.87, -19.67, -20.65, -21.64, -23.08, -24.9,
-26.51, -27.09, -26.74, -25.6, -25.14, -26.44, -26.46, -24.96, -23.63,
 -22.72, -23.36, -22.29, -21.45, -20.69)
xy1a <- cbind(x, y)

x <- c(40.61, 40.07, 40.23, 41.38, 41.38)
y <- c(-20.51, -20.49, -21.11, -21.55, -21.01)
xy1b <- cbind(x, y)

x1a <- coordsToPoly(xy1a, enmSdm::getCRS('wgs84'))
x1b <- coordsToPoly(xy1b, enmSdm::getCRS('wgs84'))
x1 <- rgeos::gUnion(x1a, x1b)

# create "x2"
x <- c(44.53, 44.18, 44.00, 42.93, 42.29, 42.71, 43.43, 47.15, 48.08,
 45.94,45.36, 45.76, 46.97, 46.87, 45.94, 45.97, 45.08, 44.50, 44.58)
y <- c(-24.27, -23.68, -22.86, -21.88, -20.56, -19.31, -20.36, -20.53,
 -20.93,-21.81, -21.64, -22.90, -23.44, -24.08, -24.76, -25.95, -25.88, -25.61, -24.46)
xy2 <- cbind(x, y)

x2 <- coordsToPoly(xy2, enmSdm::getCRS('wgs84'))

eaCrs <- enmSdm::getCRS('albersNA')

interBuff <- interpPolysByBuffer(
	x1, x2, eaCrs=eaCrs, between = 0.4, delta=10000
)

interTween <- interpPolysByTween(
	x1, x2, eaCrs='laea', between = 0.4, delta=100
)

interTween <- interTween[[1]]$poly

plot(x1, col='gray90')
plot(x2, add=TRUE)
plot(interBuff, border='red', add=TRUE)
plot(interTween, border='green', add=TRUE)
legend('bottomleft',
	legend=c('x1', 'x2', 'by buffer', 'by tween'),
	fill=c('gray90', NA, NA, NA),
	border=c('black', 'black', 'red', 'green'),
	bty='n'
)

## multiple steps
between <- seq(0, 1, by=0.1)
interTween <- interpPolysByTween(
	x1, x2, eaCrs='laea', between = between, delta=100
)

plot(x1, col='gray90')
plot(x2, add=TRUE)
for (i in seq_along(between)) {
	plot(interTween[[i]]$poly, border='green', lty='dotted', add=TRUE)
}

legend('bottomleft',
	legend=c('x1', 'x2', 'tweens'),
	fill=c('gray90', NA, NA),
	border=c('black', 'black', 'green'),
	bty='n'
)
}
}
