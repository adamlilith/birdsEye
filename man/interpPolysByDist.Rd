% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/interpPolysByDist.r
\name{interpPolysByDist}
\alias{interpPolysByDist}
\title{Interpolate between spatial shapes}
\usage{
interpPolysByDist(x1, x2, eaCrs, between = 0.5, delta = 1000, verbose = TRUE)
}
\arguments{
\item{x1}{SpatialPolygon or SpatialPolygonDataFrame object in an unprojected (WGS84) coordinate reference system.}

\item{x2}{SpatialPolygon or SpatialPolygonDataFrame object in an unprojected (WGS84) coordinate reference system.}

\item{between}{Numeric between 0 an 1. Indicates the relative distance from the object in \code{x1} to \code{x2} represented by the interpolated layer. For example, if this value is 0.5, then the interpolated layer will have a border that is exactly between \code{x1} and \code{x2}. If values are between 0 and 0.5, they are closer to \code{x1}, and if between 0.5 and 1 they are closer to \code{x2}.}

\item{delta}{Positive numeric, precision of output. The polygon that results will be "true" to the "real" polygon (in a perfect world) to within this distance typically in meters).}

\item{verbose}{Logical, if \code{TRUE} then display progress.}

\item{eaCRS}{Character string or object of class CRS. Coordinate reference system (proj4string) for an equal-area projection.}
}
\value{
A SpatialPolygons object.
}
\description{
This function generates a SpatialPolygons object that is the spatial "average" of two other SpatialPolygons or SpatialPolygonDataFrame objects. For example, assume you have two spatial polygons for ice over 12 Kybp and 10 Kybp and you wish to interpolate ice cover for 11 Kybp. Barring other information, the most parsimonious assumption is that the border of the ice 11 Kybp was exactly between the two other layers. Note that this function is different from taking values in two layers and calculating and average of them.
}
\examples{
\dontrun{
xx1 <- c(44.02, 43.5, 42.61, 42.18, 42, 42.41, 42.75, 41.75, 41.49, 43.61,
46.02, 46.5, 47.5, 47.39, 48.64, 49.05, 48.46, 48.18, 47.54, 46.73)
yy1 <- c(-18.83, -18.67, -18.87, -19.67, -20.65, -21.64, -23.08, -24.9,
-26.51, -27.09, -26.74, -25.6, -25.14, -26.44, -26.46, -24.96, -23.63, -22.72,
-23.36, -22.29)
xy1 <- cbind(xx1, yy1)

xx2 <- c(44.53, 44.18, 44.00, 42.93, 42.29, 42.71, 43.43, 45.15, 46.08, 45.94,
45.36, 45.76, 46.97, 46.87, 45.94, 45.97, 45.08, 44.50, 44.58)
yy2 <- c(-24.27, -23.68, -22.86, -21.88, -20.56, -19.31, -20.36, -20.53, -20.93,
-21.81, -21.64, -22.90, -23.44, -24.08, -24.76, -25.95, -25.88, -25.61, -24.46)
xy2 <- cbind(xx2, yy2)

x1 <- coordsToPoly(xy1, enmSdm::getCRS('wgs84'))
x2 <- coordsToPoly(xy2, enmSdm::getCRS('wgs84'))

plot(x1)
plot(x2, border='blue', add=TRUE)

eaCrs <- enmSdm::getCRS('madAlbers')

inter <- interpPolysByDist(
	x1, x2, eaCrs=eaCrs, between = 0.3, delta=10000
)

plot(inter, lty='dotted', add=TRUE)
}
}
\seealso{
\code{\link[birdsEye]{interPolysByBuffer}}
}
